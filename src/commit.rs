use std::{collections::HashMap, fs, path::Path};
use sha2::{Digest, Sha256};
use walkdir::WalkDir;
use ignore::gitignore::{Gitignore, GitignoreBuilder};
use crate::util::{read_head::read_current_head,commit_data::CommitData};

pub fn commit(commit_message: String) -> std::io::Result<()> {
    //make sure initialized
    if !Path::new(".bic").exists() {
        eprintln!("Error: not bic repository. Run `bic init` first.");
        std::process::exit(1);
    }

    let ignore = build_ignore_matcher();
    let files_map = collect_files(".", &ignore)?;
   

    //create actual commit data
    let commit_data = CommitData  {
        parent: read_current_head()?,
        message: commit_message,
        timestamp: get_current_timestamp(),
        files: files_map,
    };

    write_commit(&commit_data)?;
    println!("Commited created.");

    Ok(())
}

fn build_ignore_matcher() -> Gitignore {
    let mut builder = GitignoreBuilder::new(".");

    // read patterns from .bic_ignore
    if let Ok(contents) = fs::read_to_string(".bic_ignore") {
        for line in contents.lines() {
            let trimmed = line.trim();
            if !trimmed.is_empty() && !trimmed.starts_with('#') {
                builder.add_line(None, trimmed).unwrap();
            }
        }   
    }

    // add hardcoded patterns
    builder.add_line(None, ".git").unwrap();
    builder.add_line(None, ".bic").unwrap();

    builder.build().unwrap()
}

fn collect_files(directory: &str, ignore: &Gitignore) -> std::io::Result<HashMap<String, String>> {
    let mut files_map: HashMap<String, String> = HashMap::new();

    let walker = WalkDir::new(directory).into_iter().filter_entry(|entry| {
        let path = entry.path();
        // Don't descend into ignored folders
        !ignore.matched(path, path.is_dir()).is_ignore()
    });


    //walkdir goes through subfolders too
    for entry in walker {
        let entry = entry.unwrap();
        let path = entry.path();

        //skip non files
        if !path.is_file() {
            continue;
        }

        let file_contents = match fs::read_to_string(&path) {
            Ok(contents) => contents,
            Err(_) => continue, // skip binary or unreadable files
        };        
        let file_hash = calculate_hash(&file_contents);
        let file_name = path.strip_prefix(directory).unwrap().to_string_lossy().to_string();

        files_map.insert(file_name, file_hash.clone());
        //storing only to avoid warning generated by compiler
        let _ = store_file_object(&file_hash, &file_contents);
    }

    Ok(files_map)

}


fn calculate_hash(content: &str) -> String{
    let mut hasher = Sha256::new();
    hasher.update(content.as_bytes());
    format!("{:x}", hasher.finalize())
}

fn get_current_timestamp() -> u64 {
    use std::time::{SystemTime, UNIX_EPOCH};
    
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("time travel :scream:")
        .as_secs()
}

//writes the actual file to store into objects folder
fn store_file_object(hash: &str, content: &str) -> std::io::Result<()> {
    let object_path = format!(".bic/objects/{}", hash);
    
    // Only write if file doesn't already exist (deduplication)
    if !Path::new(&object_path).exists() {
        fs::write(&object_path, content)?;
    }
    
    Ok(())
}


//writes the json file in commits folder and change HEAD
fn write_commit(commit_data: &CommitData) -> std::io::Result<()> {
    //convert object into string to write into file
    let commit_string = serde_json::to_string_pretty(commit_data)
        .expect("Failed to serialize commit data");

    let file_hash = calculate_hash(&commit_string);
    
    let commit_path = format!(".bic/commits/{}.json", file_hash);
    fs::write(commit_path, commit_string)?;

    //change head to point to current commit
    fs::write(".bic/HEAD", file_hash)?;
    
    Ok(())
}

